#!/usr/bin/env python3
import argparse
import common
import sys
import os
import numpy as np

ap = argparse.ArgumentParser()
ap.add_argument("-i", required=True, 
    help="input folder of client circpadtrace files")
ap.add_argument("-o", required=True, 
    help="output folder to store simulated relay circpadtrace files in")

ap.add_argument('--guard', default=False, action='store_true',
    help="simulate a trace at a guard relay, not middle relay")
args = vars(ap.parse_args())

NUM_LATENCY_EST_SAMPLES = 20

def main():
    '''Given an input folder of circpadtrace files generated by torlog2circpadtrace.py using a client torlog, create a simulated trace for a guard relay or a middle relay (middle by default).

    Note that this simulation only works for nonpadding traffic. If a client
    receives padding, we can't tell from the client's trace if it's from the
    relay or not. We assume that the negotiation of the relay's padding machine
    to be later simulated is taken care by the simulator.

    The simulation estimates the latency between client-relay based on the
    timestamps in the log. This will at best be an approximation. Only use these
    generated tracers if you account for the impact of this approximation.

    Optimisation problem, overfitting if only works on exact timing. Also risk:
    imagine an attacker that subtly traffic shapes tor traffic as part of TA.
    '''

    if not os.path.isdir(args["i"]):
        sys.exit(f"{args['i']} is not a directory")
    if not os.path.isdir(args["o"]):
        sys.exit(f"{args['o']} is not a directory")

    for fname in os.listdir(args["i"]):
        infname = os.path.join(args["i"], fname)
        outfname = os.path.join(args["o"], fname)

        if os.path.exists(outfname):
            sys.exit(f"output file {outfname} already exists")

        # estimate latency distribution between client-relay
        latency = estimate_latency_in_us(infname)

        output = []
        with open(infname, 'r') as trace:
            for line in trace:
                event, timestamp = common.circpad_parse_line(line)

                if common.CIRCPAD_EVENT_NONPADDING_RECV in event:
                    t = 0
                    while(True):
                        # the relay sent a cell timestamp - latency ago
                        t = timestamp - latency()
                        if t > 0:
                            break
                    assert(t >= 0)
                    output.append(
                        f"{t:016d} {common.CIRCPAD_EVENT_NONPADDING_SENT}"
                        )
                elif common.CIRCPAD_EVENT_NONPADDING_SENT in event:
                    # the relay will receive a cell in timestamp + latency
                    t = timestamp + latency()
                    output.append(
                        f"{t:016d} {common.CIRCPAD_EVENT_NONPADDING_RECV}"
                        )

        # save results
        with open(outfname, 'w') as f:
            for l in output:
                f.write(f"{l}\n")


def estimate_latency_in_us(infname):
    ''' Builds a function to sample from, with reasonable bounds, based on data.

    We know that a circuit in Tor for web-browsing looks as follows:

    client - guard - middle - exit - destination

    The RTT value measures the time it takes from client sending a request, the
    destination creating a reply, and the reply reaching the client. This means
    that the expected latency between: 

    - client and guard is roughly 1/8 of RTT
    - client and middle is roughly 1/4 of RTT

    First we find all candidate RTT values, and then pick the highest found
    estimates. This gives us clear bounds: a maximum possible latency to the
    relay, and the minimum is obviously somewhere higher than 0 us. Mapping the
    maximum to the expected latency, listed above, gives us the upper bound for
    the latency we sample.

    Above, we use the highest values to estimate the RRT (since it's the only
    remotely reliable measures we have), they (by manual inspection) vary quite
    a lot, in the order of 100 ms. Some candidate values might not even be RRTs,
    especially if we select too many of them.
    '''
    
    # first find all candidate rtt values from a client sending a cell to
    # getting a reply
    rtt = []
    with open(infname, 'r') as trace:
        CONST_NO_SENT = -1
        latest_sent = CONST_NO_SENT
        for line in trace:
            event, timestamp = common.circpad_parse_line(line)

            if common.CIRCPAD_EVENT_NONPADDING_SENT in event:
                latest_sent = timestamp
            elif common.CIRCPAD_EVENT_NONPADDING_RECV in event:
                if latest_sent != CONST_NO_SENT:
                    rtt.append(timestamp-latest_sent)
                    latest_sent = CONST_NO_SENT

    # find the highest rrt values
    rtt.sort()
    rtt.reverse()
    print(rtt[:10])

    factor = 4
    if args["guard"]:
        factor = 8

    a = sum(rtt[:NUM_LATENCY_EST_SAMPLES])/NUM_LATENCY_EST_SAMPLES
    b = rtt[0]

    a /= factor
    b /= factor

    def sample():
        # "h√∂ftat"
        s = int(min(b, max(a, a*np.random.pareto(3))))

        # 1 ms noise 
        s += int(np.random.uniform(low=-1000.0, high=1000.0))
        print(f"a = {a}, b = {b}, s = {s}")
        return s
        
    return sample

if __name__ == "__main__":
    main()